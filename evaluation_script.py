# -*- coding: utf-8 -*-
"""evaluation_script.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-TsPtlIVmNb0XqrYtH0LTjSA0i8wmD-a
"""


import plain as p
import numpy as np
import random
import sklearn.metrics.pairwise
import scipy.spatial.distance
import _pickle as cPickle
import os, sys
from PIL import Image
import json
from sklearn.preprocessing import normalize
import numpy as np
from scipy.spatial.distance import cdist
import configparser

def distance(r):
    dists = scipy.spatial.distance.pdist(r,'cosine')
    dist_matrix=scipy.spatial.distance.squareform(dists, force='no', checks=True)
    return dist_matrix

def re_ranking(feat,k1,k2,lambda_value, MemorySave = False, Minibatch = 2000):
    #function included from https://github.com/zhunzhong07/person-re-ranking/tree/master/python-version
    #inputs: 
    #feat: apperance feature from last layer from each gallery image
    #k1: number of K nearest neighbors to consider for given test image
    #k2: number of subset images to consider for each neighbor for test image
    #lambda_value= percentage weightage for reranking matrix, if 1 then it uses only the apperance feature
    all_num= feat.shape[0]
    query_num = feat.shape[0]
    feat = feat.astype(np.float16)
    print('computing original distance')
    if MemorySave:
        original_dist = np.zeros(shape = [all_num,all_num],dtype = np.float16)
        i = 0
        while True:
            it = i + Minibatch
            if it < np.shape(feat)[0]:
                original_dist[i:it,] = np.power(cdist(feat[i:it,],feat),2).astype(np.float16)
            else:
                original_dist[i:,:] = np.power(cdist(feat[i:,],feat),2).astype(np.float16)
                break
            i = it
    else:
        # original_dist = cdist(feat,feat).astype(np.float16)  
        # original_dist = np.power(original_dist,2).astype(np.float16)
        original_dist = distance(feat).astype(np.float16)
    del feat    
    gallery_num = original_dist.shape[0]
    original_dist = np.transpose(original_dist/np.max(original_dist,axis = 0))
    V = np.zeros_like(original_dist).astype(np.float16)
    initial_rank = np.argsort(original_dist).astype(np.int32)


    
    print('starting re_ranking')
    for i in range(all_num):
        # k-reciprocal neighbors
        forward_k_neigh_index = initial_rank[i,:k1+1]
        backward_k_neigh_index = initial_rank[forward_k_neigh_index,:k1+1]
        fi = np.where(backward_k_neigh_index==i)[0]
        k_reciprocal_index = forward_k_neigh_index[fi]
        k_reciprocal_expansion_index = k_reciprocal_index
        for j in range(len(k_reciprocal_index)):
            candidate = k_reciprocal_index[j]
            candidate_forward_k_neigh_index = initial_rank[candidate,:int(np.around(k1/2))+1]
            candidate_backward_k_neigh_index = initial_rank[candidate_forward_k_neigh_index,:int(np.around(k1/2))+1]
            fi_candidate = np.where(candidate_backward_k_neigh_index == candidate)[0]
            candidate_k_reciprocal_index = candidate_forward_k_neigh_index[fi_candidate]
            if len(np.intersect1d(candidate_k_reciprocal_index,k_reciprocal_index))> 2/3*len(candidate_k_reciprocal_index):
                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index,candidate_k_reciprocal_index)
            
        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)
        weight = np.exp(-original_dist[i,k_reciprocal_expansion_index])
        V[i,k_reciprocal_expansion_index] = weight/np.sum(weight)
    original_dist = original_dist[:query_num,]    
    if k2 != 1:
        V_qe = np.zeros_like(V,dtype=np.float16)
        for i in range(all_num):
            V_qe[i,:] = np.mean(V[initial_rank[i,:k2],:],axis=0)
        V = V_qe
        del V_qe
    del initial_rank
    invIndex = []
    for i in range(gallery_num):
        invIndex.append(np.where(V[:,i] != 0)[0])
    
    jaccard_dist = np.zeros_like(original_dist,dtype = np.float16)

    
    for i in range(query_num):
        temp_min = np.zeros(shape=[1,gallery_num],dtype=np.float16)
        indNonZero = np.where(V[i,:] != 0)[0]
        indImages = []
        indImages = [invIndex[ind] for ind in indNonZero]
        for j in range(len(indNonZero)):
            temp_min[0,indImages[j]] = temp_min[0,indImages[j]]+ np.minimum(V[i,indNonZero[j]],V[indImages[j],indNonZero[j]])
        jaccard_dist[i] = 1-temp_min/(2-temp_min)
    
    final_dist = jaccard_dist*(1-lambda_value) + original_dist*lambda_value
    #del original_dist
    #del V
    #del r
    # final_dist = final_dist[:query_num,query_num:]
    return final_dist


def re_rank(data_path):
  with open(data_path, "rb") as input_file:
    e = cPickle.load(input_file)
  feat=np.array(list(e.values()))
  k1=20
  k2=6
  dist_matrix = re_ranking(feat,k1,k2,0.3, MemorySave = False, Minibatch = 2000)
  dist_matrix= normalize(dist_matrix, axis=1, norm='l2')
  return dist_matrix
  
def visualize_results(test_images_path,final_res,results_path,e):
  #functions to visualize results 
  #inputs:
  #test_images_path : path to test images
  #final_res: distance matrix from rerank function
  #results_path: path to save image
  #e: list of test images
  test_image_id=list(e.keys())[0]
  
  list_results=[]
  for ind in range(0,7):
    querry_image_id=final_res[ind]['query_id']
    querry_image_path=test_images_path+"/"+"{:06d}".format(querry_image_id)+".jpg"
    querry_image = Image.open(querry_image_path)
    querry_image = querry_image.resize((456,258), Image.ANTIALIAS)
    querry_image = np.array(querry_image)

    images_list=[]
    images_id_list=final_res[ind]['ans_ids'][:5]
    for image_id in images_id_list:
      image_path=test_images_path+"/"+"{:06d}".format(image_id)+".jpg"
      image = Image.open(image_path)
      image = image.resize((456,258), Image.ANTIALIAS)
      image = np.array(image)
      images_list.append(image)

    two=np.ones((258,50,3))*255
    top_n_image=np.hstack(images_list)
    querry_image.shape,top_n_image.shape

    final_image=np.hstack([querry_image,two,top_n_image])
    list_results.append(final_image)

  final_image=np.vstack(list_results)
  im = Image.fromarray(final_image.astype(np.uint8))
  im.save(results_path)


def main():
  config = configparser.ConfigParser()
  config.sections()
  config.read('config.ini')  

  num_of_folds=int(config["test_parameters"]["no_of_folds"])
  dist_matrix=0
  
  for i in range(num_of_folds):
    data_path=config["test_parameters"]["results_path"]+"ppbm_fold"+str(i)+".pkl"
    dist_matrix=dist_matrix+re_rank(data_path)

  dist_matrix = dist_matrix/num_of_folds
  with open(data_path, "rb") as input_file:
    e = cPickle.load(input_file)
    
  ids=[int(i.split(".")[0]) for i in np.array(list(e.keys()))]
  ids=np.array(ids)

  final_res=[]
  for k,i in enumerate(ids):
    ind=ids[np.delete(np.argsort(dist_matrix[k]),k)]
    ind=ind.tolist()
    dict_res={"query_id":ids[k].tolist(),"ans_ids":ind}
    final_res.append(dict_res)

  with open("data.pkl", 'w') as f:
      json.dump(final_res, f)
  print(p.evaluate('gt_test_plain.json',"data.pkl",'test'))
   
  if "Yes"==config["test_parameters"]["visualize"]:
   
    result_image_path=config["test_parameters"]["result_image_path"]
    test_images_path=config["test_image"]["test_images_path"]
    print("saving results collage at:", result_image_path)
    visualize_results(test_images_path,final_res,result_image_path,e)

main()
